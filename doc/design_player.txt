Player contains the game state data. 
A player should base his decision upon the following parameters:
* state		maintained as cards are distributed
* BB		maintained at Blind
* pot		maintained at pot
* mySeat	maintained at Seat
* nPlyr		maintained by class Round
* comm		maintained as cards are distributed
* seat		maintained at Seat
* plyrStates	maintained at Seat, Inquiry

* myState	maintained at Seat, Inquiry
* hole		maintained at Hold
* rdRecords	maintained at Inquiry

* opHole	maintained at Showdown
* phand		maintained at Showdown
* potsh		maintained at Pot-win

The listed parameters are retrieved with a number of methods, the more complex two of which is rcvSeat and rcvInquiry

#####rcvSeat
This method receives the following data:
* seat
* mySeat
* myState
* plyrStates
seat is received in [1 ~ n-1, 0] order so as to ensure [SB# ~ DEALER#] order.
mySeat and myState is received within the iterations
nPlyr and startStates are initialized for the first round decision of pre-flop bet (DEAL_BET)

#####rcvInquiry
This method receives the following data:
* myState
* rdRecords

###Decide: Map result info
**Justification**
Map has its clear advantage over vector in its efficiency in accessing data with id. Plus, it takes only constant time to get one's seat order from its id. It seems most adequate that I should use id as the identifier of a player, instead of seat number. And if I should wish to find the id of the player at a certain seat, I can easily implement a map that maps id back with the seat order in rcvSeat. 

* unordered_map<int, RdState> plyrStates
* unordered_map<int, ShowdownInfo> pshow
* ShowdownInfo: vector<Card>, int phand, int potsh
* TableInfo: map<int, RdState>, int pot
